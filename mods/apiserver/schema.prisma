generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// We need an ApplicationStream with a one-to-one relation to the Application model
// but it is optional, so we can have an Application without a stream.
// 
// Use the proto bellow as reference but add the websocket URL
// 
// {
//   // The session reference generated by the Media Server
//   string session_ref = 1;

//   // The direction of the stream
//   enum StreamDirection {
//     IN = 0;
//     OUT = 1;
//     BOTH = 2;
//   }
//   StreamDirection direction = 2;

//   // Output format
//   enum StreamAudioFormat {
//     WAV = 0;
//   }
//   StreamAudioFormat format = 3;

//   // Enable VAD (Voice Activity Detection)
//   bool enableVad = 4;
// }

model Application {
  ref         String          @id @default(uuid())
  accessKeyId String          @map("access_key_id")
  name        String          @db.VarChar(255)
  type        ApplicationType
  appEndpoint String          @db.VarChar(255)
  createdAt   DateTime        @default(now()) @map("created_at")
  updatedAt   DateTime        @default(now()) @map("updated_at")

  // Relations
  textToSpeech TextToSpeech?
  speechToText SpeechToText?
  conversation Conversation?
  stream       ApplicationStream?

  // Indexes and maps
  @@index([accessKeyId], type: Hash)
  @@map("applications")
}

model ApplicationStream {
  ref       String            @id @default(uuid())
  direction StreamDirection
  format    StreamAudioFormat
  enableVad Boolean

  // Relations
  application    Application @relation(fields: [applicationRef], references: [ref], onDelete: Cascade)
  applicationRef String      @unique @map("application_ref")

  // Indexes and maps
  @@index([applicationRef], type: Hash)
  @@map("application_streams")
}

model TextToSpeech {
  ref    String @id @default(uuid())
  config Json

  // Relations
  application    Application @relation(fields: [applicationRef], references: [ref], onDelete: Cascade)
  applicationRef String      @unique @map("application_ref")
  product        Product     @relation(fields: [productRef], references: [ref], onDelete: Cascade)
  productRef     String      @map("product_ref")
  secret         Secret      @relation(fields: [secretRef], references: [ref], onDelete: Cascade)
  secretRef      String      @map("secret_ref")

  // Indexes and maps
  @@index([applicationRef], type: Hash)
  @@index([productRef], type: Hash)
  @@index([secretRef], type: Hash)
  @@map("tts_services")
}

model SpeechToText {
  ref    String @id @default(uuid())
  config Json

  // Relations
  application    Application @relation(fields: [applicationRef], references: [ref], onDelete: Cascade)
  applicationRef String      @unique @map("application_ref")
  product        Product     @relation(fields: [productRef], references: [ref], onDelete: Cascade)
  productRef     String      @map("product_ref")
  secret         Secret      @relation(fields: [secretRef], references: [ref], onDelete: Cascade)
  secretRef      String      @map("secret_ref")

  // Indexes and maps
  @@index([applicationRef], type: Hash)
  @@index([productRef], type: Hash)
  @@index([secretRef], type: Hash)
  @@map("stt_services")
}

model Conversation {
  ref    String @id @default(uuid())
  config Json

  // Relations
  application    Application @relation(fields: [applicationRef], references: [ref], onDelete: Cascade)
  applicationRef String      @unique @map("application_ref")
  Product        Product     @relation(fields: [productRef], references: [ref], onDelete: Cascade)
  productRef     String      @map("product_ref")
  secret         Secret      @relation(fields: [secretRef], references: [ref], onDelete: Cascade)
  secretRef      String      @map("secret_ref")

  // Indexes and maps
  @@index([applicationRef], type: Hash)
  @@index([productRef], type: Hash)
  @@index([secretRef], type: Hash)
  @@map("conversation_services")
}

model Product {
  ref    String        @id
  name   String
  vendor ProductVendor
  type   ProductType

  // Relations
  speechToText SpeechToText[]
  sextToSpeech TextToSpeech[]
  conversation Conversation[]

  // Indexes and maps
  @@map("products")
}

model Secret {
  ref         String   @id @default(uuid())
  accessKeyId String   @map("access_key_id")
  name        String
  secret      String   @map("secret_hash") /// @encrypted
  createdAt   DateTime @default(now()) @map("created_at")
  updatedAt   DateTime @default(now()) @map("updated_at")

  // Relations
  textToSpeech TextToSpeech[]
  speechToText SpeechToText[]
  conversation Conversation[]

  // Indexes and maps
  @@index([accessKeyId], type: Hash)
  @@index([name], type: Hash)
  @@map("secrets")
}

enum ApplicationType {
  PROGRAMMABLE_VOICE
  STREAMS
  AUTOPILOT
  ENHANCED_AUTOPILOT

  // Maps
  @@map("application_types")
}

enum ProductType {
  TTS
  STT
  NLU
  ASSISTANT

  // Maps
  @@map("product_types")
}

enum ProductVendor {
  GOOGLE
  MICROSOFT
  AMAZON
  IBM
  RASA
  GENERIC

  // Maps
  @@map("product_vendors")
}

enum StreamDirection {
  IN
  OUT
  BOTH

  // Maps
  @@map("stream_directions")
}

enum StreamAudioFormat {
  WAV

  // Maps
  @@map("stream_audio_formats")
}
